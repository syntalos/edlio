# -*- coding: utf-8 -*-
#
# Copyright (C) 2020 Matthias Klumpp <matthias@tenstral.net>
#
# Licensed under the GNU Lesser General Public License Version 3
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the license, or
# (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this software.  If not, see <http://www.gnu.org/licenses/>.

import os
import struct
import json
import numpy as np
from enum import IntEnum
from datetime import datetime


__all__ = ['TsyncFile', 'TSyncFileTimeUnit']


class TSyncTimeUnit(IntEnum):
    INDEX = 0
    NANOSECONDS = 1
    MICROSECONDS = 2
    MILLISECONDS = 3
    SECONDS = 4


def read_utf8_bin_string(f):
    ''' Read UTF-8 encoded string from binary .tsync file '''

    length, = struct.unpack('<I', f.read(4))
    if length == int('ffffffff', 16):
        return ''

    if length > (os.fstat(f.fileno()).st_size - f.tell() + 1):
        raise Exception('String length in binary too long ({}).'.format(length))

    return str(f.read(length), 'utf-8')


class TsyncFile:
    '''
    Read a TimeSync (.tsync) binary file as generated by the
    Syntalos DAQ system.
    '''

    def __init__(self, fname=None):
        self._format_version = 1
        self._time_created = None
        self._tolerance = 0
        self._generator_name = ''
        self._custom = {}
        self._time_labels = ('A', 'B')
        self._time_units = (TSyncTimeUnit.MICROSECONDS,
                            TSyncTimeUnit.MICROSECONDS)
        self._times = np.empty((0,3))
        if fname:
            self.open(fname)

    @property
    def time_created(self):
        return self._time_created

    @property
    def tolerance(self) -> int:
        ''' The tolerance range value, in microseconds '''
        return self._tolerance_us

    @tolerance.setter
    def tolerance(self, usec: int):
        self._tolerance_us = usec

    @property
    def generator_name(self) -> str:
        ''' Name of the module that generated this file. '''
        return self._generator_name

    @generator_name.setter
    def generator_name(self, name: str):
        self._generator_name = name

    @property
    def custom(self) -> dict:
        ''' User-defined custom Ã¼roperties of this file. '''
        return self._custom

    @custom.setter
    def custom(self, v: dict):
        self._custom = v

    @property
    def time_labels(self):
        ''' Labels of the two encoded times. '''
        return self._time_labels

    @time_labels.setter
    def time_labels(self, v):
        self._time_labels = v

    @property
    def time_units(self):
        ''' Units of the two encoded times. '''
        return self._time_units

    @time_units.setter
    def time_units(self, v):
        self._time_units = v

    @property
    def times(self):
        ''' The actual time values of the two clocks. '''
        return self._times

    @times.setter
    def times(self, v):
        self._times = v

    def open(self, fname):
        with open(fname, 'rb') as f:
            magic_number, = struct.unpack('<I', f.read(4))
            if magic_number != int('C6BBDFBC', 16):
                raise Exception('Unrecognized file type.')

            self._format_version, = struct.unpack('<I', f.read(4))
            if self._format_version != 1:
                raise Exception('Can not read TSync format version {}'.format(self._format_version))

            ts, = struct.unpack('<q', f.read(8))
            self._time_created = datetime.utcfromtimestamp(ts)
            self._tolerance_us, = struct.unpack('<I', f.read(4))
            self._generator_name = read_utf8_bin_string(f)

            json_raw = read_utf8_bin_string(f)
            self._custom = {}
            if json_raw:
                self._custom = json.loads(json_raw)

            self._time_labels = (read_utf8_bin_string(f),
                                 read_utf8_bin_string(f))

            tuv1, = struct.unpack('<H', f.read(2))
            tuv2, = struct.unpack('<H', f.read(2))
            self._time_units = (TSyncTimeUnit(tuv1),
                                TSyncTimeUnit(tuv2))

            self._times = np.empty((0,3))
            bytes_per_block = 4 + 8 + 8
            bytes_remaining = os.fstat(f.fileno()).st_size - f.tell()
            if bytes_remaining <= 0:
                # no data is present
                return

            if bytes_remaining % bytes_per_block != 0:
                raise Exception('File may be corrupt: Not a whole number of data blocks found!')

            num_data_blocks = int(bytes_remaining / bytes_per_block)
            indices_continuous = True
            self._times = np.zeros((num_data_blocks, 3), dtype=np.int64)
            for i in range(num_data_blocks):
                index, = struct.unpack('<I', f.read(4))
                time1, = struct.unpack('<q', f.read(8))
                time2, = struct.unpack('<q', f.read(8))
                if index != i:
                    indices_continuous = False
                self._times[i] = np.array([index, time1, time2])

            if not indices_continuous:
                print('WARNING: Indices in time sync file were not continuous.')
